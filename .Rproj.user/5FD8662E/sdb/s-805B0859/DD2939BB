{
    "collab_server" : "",
    "contents" : "#' @keywords internal\nnobs.vglm <- function(object, ...) {\n  attributes(object)$misc$n\n}\n\n\n#' @keywords internal\nncat <- function(object, ...) {\n  UseMethod(\"ncat\")\n}\n\n\n#' @keywords internal\nncat.clm <- function(object, ...) {\n  length(object$y.levels)\n}\n\n\n#' @keywords internal\nncat.polr <- function(object, ...) {\n  length(object$lev)\n}\n\n\n#' @keywords internal\nncat.vglm <- function(object, ...) {\n  length(attributes(object)$extra$colnames.y)\n}\n\n\n#' @keywords internal\ngetResponseValues <- function(object, ...) {\n  UseMethod(\"getResponseValues\")\n}\n\n\n#' @keywords internal\ngetResponseValues.clm <- function(object, ...) {\n  unname(as.integer(object$y))\n}\n\n\n#' @keywords internal\ngetResponseValues.polr <- function(object, ...) {\n  if (is.null(object$model)) {\n    stop(\"Cannot extract response values from \", deparse(substitute(object)),\n         \". Please re-fit \", deparse(substitute(object)),\n         \" using the option `model = TRUE`.\")\n  } else {\n    unname(as.integer(object$model$y))\n  }\n}\n\n\n#' @keywords internal\ngetResponseValues.vglm <- function(object, ...) {\n  unname(apply(object@y, MARGIN = 1, FUN = function(x) which(x == 1)))\n}\n\n\n#' @keywords internal\ngetBounds <- function(object, ...) {\n  UseMethod(\"getBounds\")\n}\n\n\n#' @keywords internal\ngetBounds.clm <- function(object, ...) {\n  unname(\n    c(-Inf, stats::coef(object)[seq_len(ncat(object) - 1)] -\n      stats::coef(object)[1L], Inf)\n  )\n}\n\n\n#' @keywords internal\ngetBounds.polr <- function(object, ...) {\n  unname(\n    c(-Inf, object$zeta - object$zeta[1L], Inf)\n  )\n}\n\n\n#' @keywords internal\ngetBounds.vglm <- function(object, ...) {\n  unname(\n    c(-Inf, stats::coef(object)[seq_len(ncat(object) - 1)] -\n        stats::coef(object)[1L], Inf)\n  )\n}\n\n\n#' @keywords internal\ngetMeanResponse <- function(object) {  # for j = 1\n  UseMethod(\"getMeanResponse\")\n}\n\n\n#' @keywords internal\ngetMeanResponse.clm <- function(object) {\n  # Have to do this the long way, for now! :(\n  mf <- model.frame(object)\n  if (!is.null(cl <- attr(object$terms, \"dataClasses\"))) {\n    .checkMFClasses(cl, mf)\n  }\n  X <- model.matrix(object$terms, data = mf, contrasts = object$contrasts)\n  if(sum(object$aliased$beta) > 0) {\n    X <- X[, !c(FALSE, object$aliased$beta), drop = FALSE]\n  }\n  -(object$alpha[1L] - X[, -1L, drop = FALSE] %*% object$beta)[,, drop = TRUE]\n  # -predict(object, type = \"linear.predictor\")$eta2\n}\n\n\n#' @keywords internal\ngetMeanResponse.polr <- function(object) {\n  -qnorm(object$fitted.values[, 1L, drop = TRUE])\n}\n\n\n#' @keywords internal\ngetMeanResponse.vglm <- function(object) {\n  -object@predictors[, 1L, drop = TRUE]  # FIXME: Why the minus sign?\n}\n",
    "created" : 1499114247360.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1599357544",
    "id" : "DD2939BB",
    "lastKnownWriteTime" : 1499120929,
    "last_content_update" : 1499120929655,
    "path" : "~/Desktop/Dropbox/devel/ordr/R/utils.R",
    "project_path" : "R/utils.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}